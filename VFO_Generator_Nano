#include <si5351.h>          // Etherkit https://github.com/etherkit/Si5351Arduino
#include <Wire.h>            // IDE Standard
#include <SoftwareSerial.h>  // IDE Standard
#define IF 10700             // Enter your IF frequency, ex: 455 = 455kHz, 10700 = 10.7MHz, 0 = to direct convert receiver or RF generator, + will add and - will subtract IF offset.
#define BAND_INIT 18         // Enter your initial Band (1-21) at startup, ex: 1 = Freq Generator, 2 = 800kHz (MW), 7 = 7.2MHz (40m), 11 = 14.1MHz (20m).
#define XT_CAL_F 0           // Si5351 calibration factor, adjust to get exatcly 10MHz. Increasing this value will decreases the frequency and vice versa.
#define S_GAIN 505           // Adjust the sensitivity of Signal Meter A/D input: 101 = 500mv; 202 = 1v; 303 = 1.5v; 404 = 2v; 505 = 2.5v; 1010 = 5v (max).
#define tunestep 9           // The pin used by tune step push button.
#define band A0              // The pin used by band selector push button.
#define adc A1               // The pin used by Signal Meter A/D input.
#define rx_tx 10             // The pin used by RX / TX selector switch, RX = switch open, TX = switch closed to GND. When in TX, the IF value is not considered.
#define TX_PIN 11            // SoftwareSerial TX pin
#define RX_PIN 12            // SoftwareSerial RX pin
#define BAUD 9600            // SoftwareSerial baud rate
//------------------------------------------------------------------------------------------------------------
Si5351 si5351(0x60);
SoftwareSerial rp(TX_PIN, RX_PIN);
unsigned long freq, freqold, fstep;
long interfreq = IF, interfreqold = 0;
long cal = XT_CAL_F;
unsigned int smval;
byte encoder = 1;
byte stp, n = 1;
byte count, x, xo;
bool sts = 0;
unsigned int period = 100;
unsigned long time_now = 0;
const uint32_t beatIntervalMs = 3000;
static uint32_t lastBeatMs = 0;
const uint32_t queryIntervalMs = 10000;
static uint32_t lastQueryMs = 0;
// --- TX/RX debounced state and spam control ---
const unsigned long RXTX_DEBOUNCE_MS = 30;
static bool lastRawTx = false;
static bool debouncedTx = false;
static bool lastAnnouncedTx = false;
static unsigned long rxtxLastEdgeMs = 0;
// --------- Line Reader (newline-terminated) ----------
static const size_t CMD_BUF_SZ = 255;
static char rpRxBuf[CMD_BUF_SZ];
static size_t rpRxLen = 0;
void rplog(const char* msg, Stream& io = rp, bool addNewline = false, unsigned perCharDelayMs = 50) {
  // Existing debug writer (kept, but we pass perCharDelayMs=0)
  if (!msg) return;
  for (const char* p = msg; *p; ++p) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write((uint8_t)*p);
    yield();
  }
  if (addNewline) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write('\n');
  }
}
void rplog(const String& msg, Stream& io = rp, bool addNewline = false, unsigned perCharDelayMs = 50) {
  for (size_t i = 0; i < msg.length(); ++i) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write((uint8_t)msg[i]);
    yield();
  }
  if (addNewline) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write('\n');
  }
}
bool readLine(Stream& s, char* outBuf, size_t& inoutLen, size_t outSz) {
  // Non-blocking line reader for any Stream. Returns true when a line (ending in '\n') is assembled.
  // The line in outBuf is null-terminated and does not include CR/LF.
  while (s.available()) {
    //delay(50);
    char c = (char)s.read();
    if (c == '\r') {
      continue;  // ignore CR
    } else if (c == '\n') {
      // terminate line
      if (inoutLen < outSz) outBuf[inoutLen] = '\0';
      else outBuf[outSz - 1] = '\0';
      inoutLen = 0;  // reset for next line
      return true;
    } else {
      if (inoutLen < (outSz - 1)) {
        outBuf[inoutLen++] = c;
      } else {
        // overflow, reset (drop line)
        inoutLen = 0;
      }
    }
  }
  return false;
}
// --------- Minimal TX helpers (newline-terminated) ----------
void sendToken(const char* tok) {
  // Use rplog with no per-char delay and add newline
  rplog(tok, rp, true, 0);
}
void sendKV(const char* key, long value) {
  // "KEY <value>\n"
  rplog(String(key) + " " + String(value), rp, true, 0);
}
void pollRxTx() {
  bool raw = (digitalRead(rx_tx) == LOW);  // LOW = TX
  unsigned long now = millis();
  if (raw != lastRawTx) {
    lastRawTx = raw;
    rxtxLastEdgeMs = now;
  }
  if ((now - rxtxLastEdgeMs) >= RXTX_DEBOUNCE_MS && debouncedTx != lastRawTx) {
    debouncedTx = lastRawTx;
    sts = debouncedTx ? 1 : 0;
    if (debouncedTx != lastAnnouncedTx) {
      lastAnnouncedTx = debouncedTx;
      rp.println(debouncedTx ? "TX" : "RX");
      // Retune immediately so IF=0 (TX) or IF=IF_kHz (RX) is applied
      tunegen();
      // keep freqold in sync so the loop() change detector doesn't fire redundantly
      freqold = freq;
      interfreqold = interfreq;
    }
  }
}
int freeRam() {
  int size = 2048;
  byte* buf;
  while ((buf = (byte*)malloc(--size)) == NULL)
    ;
  free(buf);
  return size;
}
// --------- Help Text ----------
void sendHelp() {
  // --------- Console Help (Nano) ----------
  rplog(F("_ Nano Help:\n"), rp);
  rplog(F("_   HELP | ? | H             - show this help\n"), rp);
  rplog(F("_   P                        - ping (returns 'P')\n"), rp);
  rplog(F("_   PING                     - send 'PONG'\n"), rp);
  rplog(F("_   READY?                   - send 'READY'\n"), rp);
  rplog(F("_   F <Hz>                   - set RF frequency (Hz)\n"), rp);
  rplog(F("_   IF <kHz>                 - set IF (kHz)\n"), rp);
  rplog(F("_   BAND <1..21>             - set band index\n"), rp);
  rplog(F("_   STP <1..6>               - set step index\n"), rp);
  rplog(F("_   STS <0|1>                - set RX/TX (0=RX, 1=TX)\n"), rp);
  rplog(F("_   N <1..42>                - set tune pointer\n"), rp);

  rplog(F("_ SCAN:\n"), rp);
  rplog(F("_   SCAN START [H|C] [ms]    - start scan (source and delay optional)\n"), rp);
  rplog(F("_   SCAN START [H|C] D <ms>  - alternate delay form\n"), rp);
  rplog(F("_   SCAN STOP                - stop scanning\n"), rp);
  rplog(F("_   SCAN?                    - status (SCAN,SRC,DELAY,LEN)\n"), rp);
  rplog(F("_   SCAN USE H|C             - select hard/custom list\n"), rp);
  rplog(F("_   SDELAY <ms>              - set scan step delay\n"), rp);
  rplog(F("_   SLADD <Hz>               - add freq (Hz) to custom list\n"), rp);
  rplog(F("_   SLCLR                    - clear custom list\n"), rp);

  rplog(F("_ NOTES:\n"), rp);
  rplog(F("_   - TX pauses scanning automatically; RX resumes.\n"), rp);
  rplog(F("_   - Post-tuning, device emits 'K'. Signal meter: 'SM <1..14>'.\n"), rp);
}
// --------- Frequency Scanner ----------
static bool scanOn = false;
static uint8_t scanSrc = 0;          // 0 = hard-coded list, 1 = custom list
static uint32_t scanDelayMs = 1000;  // per-step delay
static uint32_t lastScanMs = 0;
static size_t scanIdx = 0;
static const uint32_t hardScanList[] = {
  // Hard-coded scan list (edit to taste, Hz):
  1000000UL,   // 1.000 MHz
  1600000UL,   // 1.600 MHz
  3500000UL,   // 3.500 MHz
  7000000UL,   // 7.000 MHz
  10000000UL,  // 10.000 MHz
  14000000UL,  // 14.000 MHz
  18068000UL,  // 18.068 MHz
  21000000UL,  // 21.000 MHz
  24890000UL,  // 24.890 MHz
  28000000UL   // 28.000 MHz
};
static const size_t hardScanLen = sizeof(hardScanList) / sizeof(hardScanList[0]);
static const size_t MAX_CUSTOM_SCAN = 16;
static uint32_t customScanList[MAX_CUSTOM_SCAN];
static size_t customScanLen = 0;
static inline size_t currentListLen() {
  return (scanSrc ? customScanLen : hardScanLen);
}
static inline const uint32_t* currentListPtr() {
  return (scanSrc ? customScanList : hardScanList);
}
void scanUse(uint8_t src) {
  scanSrc = (src ? 1 : 0);
}
void scanStart() {
  if (currentListLen() == 0) {
    rplog(F("_ ERR NO_LIST\n"), rp);
    return;
  }
  scanOn = true;
  scanIdx = 0;
  // Step immediately on start:
  lastScanMs = millis() - scanDelayMs;
  rplog(F("_ SCAN 1\n"), rp);
}
void scanStop() {
  scanOn = false;
  rplog(F("_ SCAN 0\n"), rp);
}
void scanTick() {
  if (!scanOn) return;
  // Pause scanning in TX (sts==1), resume in RX automatically
  if (sts) return;

  size_t len = currentListLen();
  if (len == 0) {
    scanStop();
    return;
  }

  uint32_t now = millis();
  if ((now - lastScanMs) >= scanDelayMs) {
    lastScanMs = now;
    const uint32_t* list = currentListPtr();
    freq = list[scanIdx];  // Hz
    tunegen();             // retune now
    freqold = freq;        // keep change detector quiet
    scanIdx = (scanIdx + 1) % len;
  }
}
// --------- Optional: handle inbound commands to Nano ----------
void handleInboundFromRP(const char* line) {
  // Examples:
  // "PING" -> respond "PONG"
  // "F 12345678" -> could be used to set local SI5351 (not implemented here)
  // "SM 10" -> could be used to adjust something (ignored here)
  if (line[0] == '\0') return;
  if (!strcmp(line, "P")) {
    sendToken("P");
    return;
  }
  if (!strcmp(line, "PING")) {
    sendToken("PONG");
    return;
  }
  if (!strcmp(line, "READY?")) {
    delay(1000);
    rplog(F("READY\n"), rp);
    return;
  }
  if (!strcmp(line, "OK")) return;
  if (!strcmp(line, "HELP") || !strcmp(line, "?") || !strcmp(line, "H")) {
    sendHelp();
    return;
  }
  // --- Scanner: status query
  if (!strcmp(line, "SCAN?")) {
    rplog(F("_ Scan values query:\n"), rp);
    sendKV("_ SCAN", scanOn ? 1 : 0);
    sendKV("_ SRC", scanSrc ? 1 : 0);  // 0=hard, 1=custom
    sendKV("_ DELAY", (long)scanDelayMs);
    sendKV("_ LEN", (long)currentListLen());
    return;
  }
  // --- Scanner: clear custom list
  if (!strcmp(line, "SLCLR")) {
    customScanLen = 0;
    rplog(F("OK\n"), rp);
    return;
  }
  // --- Scanner: add a custom frequency (Hz)
  if (!strncmp(line, "SLADD ", 6)) {
    rplog(F("_ Scan list add:\n"), rp);
    long v = atol(line + 6);
    if (v <= 0) {
      rplog(F("_ ERR BAD_FREQ\n"), rp);
      return;
    }
    if (customScanLen >= MAX_CUSTOM_SCAN) {
      rplog(F("_ ERR FULL\n"), rp);
      return;
    }
    customScanList[customScanLen++] = (uint32_t)v;
    sendKV("_ LEN", (long)customScanLen);
    return;
  }
  // --- Scanner: set step delay (ms)
  if (!strncmp(line, "SDELAY ", 7)) {
    rplog(F("_ Scan delay:\n"), rp);
    long v = atol(line + 7);
    if (v < 10) v = 10;  // clamp minimal delay
    scanDelayMs = (uint32_t)v;
    sendKV("_ DELAY", (long)scanDelayMs);
    return;
  }
  // --- Scanner: select source (hard/custom)
  if (!strncmp(line, "SCAN USE ", 9)) {
    rplog(F("_ Scan source (hard/custom):\n"), rp);
    const char* p = line + 9;
    if (!strcasecmp(p, "H") || !strcasecmp(p, "HARD")) {
      scanUse(0);
    } else if (!strcasecmp(p, "C") || !strcasecmp(p, "CUSTOM")) {
      scanUse(1);
    } else {
      rplog(F("_ ERR SRC\n"), rp);
      return;
    }
    sendKV("_ SRC", scanSrc ? 1 : 0);
    return;
  }
  // --- Scanner: START/STOP with optional args
  if (!strncmp(line, "SCAN ", 5)) {
    rplog(F("_ Scan status query:\n"), rp);
    // tokenize small command (up to 6 tokens)
    char buf[CMD_BUF_SZ];
    strncpy(buf, line, CMD_BUF_SZ - 1);
    buf[CMD_BUF_SZ - 1] = '\0';
    char* toks[6] = { 0 };
    int nt = 0;
    char* savep = nullptr;
    char* tk = strtok_r(buf, " ", &savep);
    while (tk && nt < 6) {
      toks[nt++] = tk;
      tk = strtok_r(nullptr, " ", &savep);
    }
    if (nt >= 2 && !strcasecmp(toks[1], "STOP")) {
      scanStop();
      return;
    }
    if (nt >= 2 && !strcasecmp(toks[1], "START")) {
      // Optional args: H|C and/or <ms> or "D <ms>"
      uint8_t src = scanSrc;
      uint32_t delayMs = scanDelayMs;
      for (int i = 2; i < nt; ++i) {
        if (!toks[i]) continue;
        if (!strcasecmp(toks[i], "H") || !strcasecmp(toks[i], "HARD")) {
          src = 0;
        } else if (!strcasecmp(toks[i], "C") || !strcasecmp(toks[i], "CUSTOM")) {
          src = 1;
        } else if (!strcasecmp(toks[i], "D")) {
          if (i + 1 < nt) {
            long v = atol(toks[i + 1]);
            if (v >= 10) delayMs = (uint32_t)v;
            i++;
          }
        } else if (toks[i][0] >= '0' && toks[i][0] <= '9') {
          long v = atol(toks[i]);
          if (v >= 10) delayMs = (uint32_t)v;
        }
      }
      scanUse(src);
      scanDelayMs = delayMs;
      scanStart();
      return;
    }
    // Unknown SCAN subcommand
    rplog(F("_ ERR SCAN\n"), rp);
    return;
  }
  // Parse KEY [VALUE]
  char key[8] = { 0 };
  long val = 0;
  int matched = sscanf(line, "%7s %ld", key, &val);
  if (matched >= 1) {
    if (!strcmp(key, "F") && matched == 2) {
      // Authoritative frequency in Hz
      freq = (unsigned long)val;
    } else if (!strcmp(key, "IF") && matched == 2) {
      // Authoritative IF in kHz
      interfreq = val;
    } else if (!strcmp(key, "SM") && matched == 2) {
      // Authoritative signal meter bucket 1..14
      if (val < 1) val = 1;
      if (val > 14) val = 14;
      x = (byte)val;
    } else if (!strcmp(key, "BAND") && matched == 2) {
      // Authoritative band index 1..21
      if (val < 1) val = 1;
      if (val > 21) val = 21;
      count = (byte)val;
    } else if (!strcmp(key, "STP") && matched == 2) {
      // Authoritative step index 1..6 (index, not Hz)
      if (val < 1) val = 1;
      if (val > 6) val = 6;
      stp = (byte)val;
    } else if (!strcmp(key, "STS") && matched == 2) {
      // Authoritative RX/TX from RP (0=RX, 1=TX)
      sts = (val != 0);
      // Note: We keep physical switch debounce logic in pollRxTx() authoritative for sending updates.
    } else if (!strcmp(key, "N") && matched == 2) {
      // Authoritative tune pointer 1..42
      if (val < 1) val = 1;
      if (val > 42) val = 42;
      n = (byte)val;
    }
  }
}
// --------- Signal meter sampling + send when changed ----------
uint8_t lastSMBucket = 0;
unsigned long lastSMSendMs = 0;
const unsigned long SM_MIN_SEND_INTERVAL_MS = 50;  // don't spam
void sampleAndSendSignalMeter() {
  unsigned int raw = analogRead(adc);
  // Map 0..S_GAIN to 1..14 (clamp at bounds)
  uint8_t bucket = map(raw, 0, S_GAIN, 1, 14);
  if (bucket > 14) bucket = 14;
  if (bucket < 1) bucket = 1;
  unsigned long now = millis();
  if (bucket != lastSMBucket && (now - lastSMSendMs) >= SM_MIN_SEND_INTERVAL_MS) {
    lastSMBucket = bucket;
    lastSMSendMs = now;
    sendKV("SM", bucket);  // e.g., "SM 12\n"
  }
}
//------------------------------------------------------------------------------------------------------------
void setup() {
  Wire.setClock(100000);
  Wire.begin();
  pinMode(tunestep, INPUT_PULLUP);
  pinMode(band, INPUT_PULLUP);
  pinMode(rx_tx, INPUT_PULLUP);
  rp.begin(BAUD);
  rplog(F("P\n"), rp);
  si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0);
  si5351.set_correction(cal, SI5351_PLL_INPUT_XO);
  si5351.drive_strength(SI5351_CLK0, SI5351_DRIVE_8MA);
  si5351.output_enable(SI5351_CLK0, 1);
  si5351.output_enable(SI5351_CLK1, 0);
  si5351.output_enable(SI5351_CLK2, 0);
  // Initialize TX/RX state and announce once
  lastRawTx = (digitalRead(rx_tx) == LOW);  // LOW = TX (per your comment)
  debouncedTx = lastRawTx;
  lastAnnouncedTx = debouncedTx;
  sts = debouncedTx ? 1 : 0;              // optional local mirror
  rp.println(debouncedTx ? "TX" : "RX");  // newline-terminated
  // Ask RP2040 to send its current state so we can resync
  rplog(F("Q\n"), rp);
}
void loop() {
  // Non-blocking read and process complete lines from RP2040
  if (readLine(rp, rpRxBuf, rpRxLen, CMD_BUF_SZ)) handleInboundFromRP(rpRxBuf);
  // Encoder and buttons
  pollRxTx();
  if (digitalRead(tunestep) == LOW) {
    time_now = (millis() + 750);
    sendToken("T");
    delay(750);
  }
  if (digitalRead(band) == LOW) {
    time_now = (millis() + 750);
    sendToken("B");
    delay(750);
  }
  if (freqold != freq) {
    time_now = millis();
    tunegen();
    freqold = freq;
  }
  if (interfreqold != interfreq) {
    time_now = millis();
    tunegen();
    interfreqold = interfreq;
  }
  if (xo != x) {
    time_now = millis();
    xo = x;
  }
  // Periodically sample and send signal meter bucket when it changes
  sampleAndSendSignalMeter();
  // Scanner progresses here (non-blocking); pauses automatically during TX
  scanTick();
  uint32_t now = millis();
  if ((now - lastBeatMs) >= beatIntervalMs) {
    lastBeatMs += beatIntervalMs;  // drift-free scheduling
    rplog(F("P\n"), rp);
  }
  if ((now - lastQueryMs) >= queryIntervalMs) {
    lastQueryMs += queryIntervalMs;
    rplog(F("Q\n"), rp);
  }
}
void tunegen() {
  // Use IF only in RX. In TX, drive the carrier directly at freq.
  uint32_t ifHz = sts ? 0UL : (uint32_t)interfreq * 1000UL;  // interfreq is kHz -> Hz
  uint64_t outCentiHz = ((uint64_t)freq + (uint64_t)ifHz) * 100ULL;
  si5351.set_freq(outCentiHz, SI5351_CLK0);
  rplog(F("K\n"), rp);
}
