#include <si5351.h>          // Etherkit https://github.com/etherkit/Si5351Arduino
#include <Wire.h>            // IDE Standard
#include <SoftwareSerial.h>  // IDE Standard
#define IF 10700             // Enter your IF frequency, ex: 455 = 455kHz, 10700 = 10.7MHz, 0 = to direct convert receiver or RF generator, + will add and - will subtract IF offset.
#define BAND_INIT 18         // Enter your initial Band (1-21) at startup, ex: 1 = Freq Generator, 2 = 800kHz (MW), 7 = 7.2MHz (40m), 11 = 14.1MHz (20m).
#define XT_CAL_F 0           // Si5351 calibration factor, adjust to get exatcly 10MHz. Increasing this value will decreases the frequency and vice versa.
#define S_GAIN 505           // Adjust the sensitivity of Signal Meter A/D input: 101 = 500mv; 202 = 1v; 303 = 1.5v; 404 = 2v; 505 = 2.5v; 1010 = 5v (max).
#define tunestep 9           // The pin used by tune step push button.
#define band A0              // The pin used by band selector push button.
#define adc A1               // The pin used by Signal Meter A/D input.
#define rx_tx 10             // The pin used by RX / TX selector switch, RX = switch open, TX = switch closed to GND. When in TX, the IF value is not considered.
#define TX_PIN 11            // SoftwareSerial TX pin
#define RX_PIN 12            // SoftwareSerial RX pin
#define BAUD 9600            // SoftwareSerial baud rate
//------------------------------------------------------------------------------------------------------------
Si5351 si5351(0x60);
SoftwareSerial rp(TX_PIN, RX_PIN);
unsigned long freq, freqold, fstep;
long interfreq = IF, interfreqold = 0;
long cal = XT_CAL_F;
unsigned int smval;
byte encoder = 1;
byte stp, n = 1;
byte count, x, xo;
bool sts = 0;
unsigned int period = 100;
unsigned long time_now = 0;
const uint32_t beatIntervalMs = 3000;
static uint32_t lastBeatMs = 0;
const uint32_t queryIntervalMs = 10000;
static uint32_t lastQueryMs = 0;
void(* resetFunc) (void) = 0;
// --- TX/RX debounced state and spam control ---
const unsigned long RXTX_DEBOUNCE_MS = 30;
static bool lastRawTx = false;
static bool debouncedTx = false;
static bool lastAnnouncedTx = false;
static unsigned long rxtxLastEdgeMs = 0;
// --------- Line Reader (newline-terminated) ----------
static const size_t CMD_BUF_SZ = 255;
static char rpRxBuf[CMD_BUF_SZ];
static size_t rpRxLen = 0;

void rplog(const char* msg, Stream& io = rp, bool addNewline = false, unsigned perCharDelayMs = 50) {
  if (!msg) return;
  for (const char* p = msg; *p; ++p) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write((uint8_t)*p);
    yield();
  }
  if (addNewline) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write('\n');
  }
}
void rplog(const String& msg, Stream& io = rp, bool addNewline = false, unsigned perCharDelayMs = 50) {
  for (size_t i = 0; i < msg.length(); ++i) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write((uint8_t)msg[i]);
    yield();
  }
  if (addNewline) {
    if (perCharDelayMs) delay(perCharDelayMs);
    io.write('\n');
  }
}
bool readLine(Stream& s, char* outBuf, size_t& inoutLen, size_t outSz) {
  while (s.available()) {
    char c = (char)s.read();
    if (c == '\r') {
      continue;
    } else if (c == '\n') {
      if (inoutLen < outSz) outBuf[inoutLen] = '\0';
      else outBuf[outSz - 1] = '\0';
      inoutLen = 0;
      return true;
    } else {
      if (inoutLen < (outSz - 1)) {
        outBuf[inoutLen++] = c;
      } else {
        inoutLen = 0;
      }
    }
  }
  return false;
}

// --------- SYNC gating ----------
static bool syncOK = false;
static bool scanGatePending = false;
static uint32_t lastRPSyncHash = 0;
static unsigned long lastSyncReqMs = 0;
static const unsigned long SYNC_RETRY_MS = 1500;
// For debug/diags
static long rp_band_init = -1;
static long rp_s_gain = -1;

// FNV-1a 32-bit
static inline uint32_t fnv1aMix32(uint32_t h, uint32_t v) {
  h ^= v;
  h *= 16777619UL;
  return h;
}
static uint32_t computeSyncHashNano() {
  uint32_t h = 2166136261UL;
  h = fnv1aMix32(h, (uint32_t)freq);
  h = fnv1aMix32(h, (uint32_t)interfreq);
  h = fnv1aMix32(h, (uint32_t)BAND_INIT);
  h = fnv1aMix32(h, (uint32_t)S_GAIN);
  h = fnv1aMix32(h, (uint32_t)freqold);
  h = fnv1aMix32(h, (uint32_t)fstep);
  h = fnv1aMix32(h, (uint32_t)x);  // sm bucket
  return h;
}
static void requestSync() {
  rplog(F("SYNC?\n"), rp);
  lastSyncReqMs = millis();
}
static bool ensureSyncBeforeScan() {
  if (syncOK) return true;
  // Ask RP for full state + hash
  requestSync();
  scanGatePending = true;
  rplog(F("_ WAIT SYNC\n"), rp);
  return false;
}
// --------- Minimal TX helpers (newline-terminated) ----------
void sendToken(const char* tok) {
  rplog(tok, rp, true, 0);
}
void sendKV(const char* key, long value) {
  rplog(String(key) + " " + String(value), rp, true, 0);
}
void pollRxTx() {
  bool raw = (digitalRead(rx_tx) == LOW);  // LOW = TX
  unsigned long now = millis();
  if (raw != lastRawTx) {
    lastRawTx = raw;
    rxtxLastEdgeMs = now;
  }
  if ((now - rxtxLastEdgeMs) >= RXTX_DEBOUNCE_MS && debouncedTx != lastRawTx) {
    debouncedTx = lastRawTx;
    sts = debouncedTx ? 1 : 0;
    if (debouncedTx != lastAnnouncedTx) {
      lastAnnouncedTx = debouncedTx;
      rp.println(debouncedTx ? "TX" : "RX");
      tunegen();
      freqold = freq;
      interfreqold = interfreq;
    }
  }
}
int freeRam() {
  int size = 2048;
  byte* buf;
  while ((buf = (byte*)malloc(--size)) == NULL)
    ;
  free(buf);
  return size;
}
// --------- Help Text ----------
void sendHelp() {
  rplog(F("_ Nano Help:\n"), rp);
  rplog(F("_   HELP | ? | H             - show this help\n"), rp);
  rplog(F("_   P                        - ping (returns 'P')\n"), rp);
  rplog(F("_   PING                     - send 'PONG'\n"), rp);
  rplog(F("_   READY?                   - send 'READY'\n"), rp);
  rplog(F("_   F <Hz>                   - set RF frequency (Hz)\n"), rp);
  rplog(F("_   IF <kHz>                 - set IF (kHz)\n"), rp);
  rplog(F("_   BAND <1..21>             - set band index\n"), rp);
  rplog(F("_   STP <1..6>               - set step index\n"), rp);
  rplog(F("_   STS <0|1>                - set RX/TX (0=RX, 1=TX)\n"), rp);
  rplog(F("_   N <1..42>                - set tune pointer\n"), rp);
  rplog(F("_ SCAN:\n"), rp);
  rplog(F("_   SCAN START [H|C] [ms]    - start scan (source and delay optional)\n"), rp);
  rplog(F("_   SCAN START [H|C] D <ms>  - alternate delay form\n"), rp);
  rplog(F("_   SCAN STOP                - stop scanning\n"), rp);
  rplog(F("_   SCAN?                    - status (SCAN,SRC,DELAY,LEN)\n"), rp);
  rplog(F("_   SCAN USE H|C             - select hard/custom list\n"), rp);
  rplog(F("_   SDELAY <ms>              - set scan step delay\n"), rp);
  rplog(F("_   SLADD <Hz>               - add freq (Hz) to custom list\n"), rp);
  rplog(F("_   SLCLR                    - clear custom list\n"), rp);
  rplog(F("_ NOTES:\n"), rp);
  rplog(F("_   - TX pauses scanning automatically; RX resumes.\n"), rp);
  rplog(F("_   - Post-tuning, device emits 'K'. Signal meter: 'SM <1..14>'.\n"), rp);
}
// --------- Frequency Scanner ----------
static bool scanOn = false;
static uint8_t scanSrc = 0;          // 0 = hard-coded list, 1 = custom list
static uint32_t scanDelayMs = 1000;  // per-step delay
static uint32_t lastScanMs = 0;
static size_t scanIdx = 0;
static const uint32_t hardScanList[] = {
  // Time signals (WWV/WWVH/WWVB/CHU)
  60000UL,     // 0.060 MHz - WWVB (US time standard, LF)
  2500000UL,   // 2.5 MHz  - WWV/WWVH
  3330000UL,   // 3.33 MHz - CHU (Canada)
  5000000UL,   // 5 MHz    - WWV/WWVH
  7850000UL,   // 7.85 MHz - CHU
  10000000UL,  // 10 MHz   - WWV/WWVH
  14670000UL,  // 14.67 MHz- CHU
  15000000UL,  // 15 MHz   - WWV/WWVH
  20000000UL,  // 20 MHz   - WWV

  // Maritime MF distress/calling (SSB/DSC)
  2182000UL,  // 2.182 MHz - International MF distress/calling (voice/SSB)
  2187500UL,  // 2.1875 MHz- MF DSC (digital selective calling)

  // Amateur HF digital/calling/nets
  3573000UL,   // 3.573 MHz - 80m FT8
  7074000UL,   // 7.074 MHz - 40m FT8
  10136000UL,  // 10.136 MHz- 30m FT8
  14074000UL,  // 14.074 MHz- 20m FT8
  14100000UL,  // 14.100 MHz- IBP beacon segment
  14300000UL,  // 14.300 MHz- Maritime Mobile Net / common 20m net freq
  18100000UL,  // 18.100 MHz- 17m FT8
  18110000UL,  // 18.110 MHz- IBP beacons (17m)
  21074000UL,  // 21.074 MHz- 15m FT8
  21150000UL,  // 21.150 MHz- IBP beacons (15m)
  24915000UL,  // 24.915 MHz- 12m FT8
  24930000UL,  // 24.930 MHz- IBP beacons (12m)
  28074000UL,  // 28.074 MHz- 10m FT8
  28200000UL,  // 28.200 MHz- 10m beacons (IBP + others)

  // CB radio (AM; some SSB activity)
  26965000UL,  // 26.965 MHz - CB Ch 1
  27025000UL,  // 27.025 MHz - CB Ch 6 (AM "Super Bowl")
  27065000UL,  // 27.065 MHz - CB Ch 9 (Emergency)
  27185000UL,  // 27.185 MHz - CB Ch 19 (Highway)
  27385000UL,  // 27.385 MHz - CB Ch 38 LSB (SSB calling/hangout)
  27405000UL,  // 27.405 MHz - CB Ch 40

  // 6 meters (50 MHz amateur)
  50125000UL,  // 50.125 MHz - 6m SSB calling
  50313000UL,  // 50.313 MHz - 6m FT8
  52525000UL,  // 52.525 MHz - 6m FM simplex calling

  // Aviation (AM)
  121500000UL,  // 121.500 MHz - International airband emergency (VHF Guard)
  122200000UL,  // 122.200 MHz - Common Flight Service / GA use
  122800000UL,  // 122.800 MHz - Common CTAF/UNICOM (GA)
  123450000UL,  // 123.450 MHz - Air-to-air (informal, often used)

  // NOAA weather satellites (APT) - if your receiver supports them
  137100000UL,  // 137.100 MHz - NOAA/Met APT downlink (NOAA-19)
  137620000UL,  // 137.620 MHz - NOAA-15 APT
  137912500UL,  // 137.9125 MHz- NOAA-18 APT

  // 2 meters (144â€“148 MHz amateur)
  144200000UL,  // 144.200 MHz - 2m SSB calling
  144390000UL,  // 144.390 MHz - APRS (USA)
  145800000UL,  // 145.800 MHz - ISS voice downlink (worldwide)
  145825000UL,  // 145.825 MHz - ISS packet/APRS digipeater
  146520000UL,  // 146.520 MHz - 2m FM national simplex calling (USA)

  // VHF public safety interop (NFM; USA nationwide)
  151137500UL,  // 151.1375 MHz - VTAC11
  154265000UL,  // 154.2650 MHz - Fireground White
  154280000UL,  // 154.2800 MHz - Fire Mutual Aid (VFIRE21)
  154295000UL,  // 154.2950 MHz - Fireground Red
  154452500UL,  // 154.4525 MHz - VTAC12
  155160000UL,  // 155.1600 MHz - National SAR/EMS (often used)
  155340000UL,  // 155.3400 MHz - EMS-to-hospital (HEAR, legacy)
  155370000UL,  // 155.3700 MHz - Intercity/Mutual Aid (legacy)
  155475000UL,  // 155.4750 MHz - National Law (NLEEF/NLEEC)
  155752500UL,  // 155.7525 MHz - VCALL10

  // Marine VHF (FM)
  156450000UL,  // 156.450 MHz - Marine Ch 9 (Hailing)
  156650000UL,  // 156.650 MHz - Marine Ch 13 (Bridge-to-bridge)
  156800000UL,  // 156.800 MHz - Marine Ch 16 (Distress/Calling)
  157100000UL,  // 157.100 MHz - Marine Ch 22A (USCG liaison)

  // Railroad (N. America AAR channels; NFM)
  160215000UL,  // 160.215 MHz - AAR Ch 01 (road)
  160230000UL,  // 160.230 MHz - AAR Ch 08 (road)
  160800000UL,  // 160.800 MHz - AAR Ch 24 (road)
  161550000UL,  // 161.550 MHz - AAR Ch 96 (road)

  // NOAA Weather Radio (FM)
  162400000UL,  // 162.400 MHz - WX Ch 1
  162425000UL,  // 162.425 MHz - WX Ch 2
  162450000UL,  // 162.450 MHz - WX Ch 3
  162475000UL,  // 162.475 MHz - WX Ch 4
  162500000UL,  // 162.500 MHz - WX Ch 5
  162525000UL,  // 162.525 MHz - WX Ch 6
  162550000UL   // 162.550 MHz - WX Ch 7
};
static const size_t hardScanLen = sizeof(hardScanList) / sizeof(hardScanList[0]);
static const size_t MAX_CUSTOM_SCAN = 16;
static uint32_t customScanList[MAX_CUSTOM_SCAN];
static size_t customScanLen = 0;
static inline size_t currentListLen() {
  return (scanSrc ? customScanLen : hardScanLen);
}
static inline const uint32_t* currentListPtr() {
  return (scanSrc ? customScanList : hardScanList);
}
void scanUse(uint8_t src) {
  scanSrc = (src ? 1 : 0);
}

void doScanStartNow() {
  // Internal immediate start (was scanStart)
  if (currentListLen() == 0) {
    rplog(F("_ ERR NO_LIST\n"), rp);
    return;
  }
  scanOn = true;
  scanIdx = 0;
  lastScanMs = millis() - scanDelayMs;
  rplog(F("_ SCAN 1\n"), rp);
}
// Gated start (ensures sync before starting)
void scanStart() {
  if (!ensureSyncBeforeScan()) {
    // Defer; we will start after SYNC OK
    return;
  }
  doScanStartNow();
}

void scanStop() {
  scanOn = false;
  rplog(F("_ SCAN 0\n"), rp);
}
void scanTick() {
  if (!scanOn) return;
  if (sts) return;
  size_t len = currentListLen();
  if (len == 0) {
    scanStop();
    return;
  }
  uint32_t now = millis();
  if ((now - lastScanMs) >= scanDelayMs) {
    lastScanMs = now;
    const uint32_t* list = currentListPtr();
    freq = list[scanIdx];
    tunegen();
    freqold = freq;
    scanIdx = (scanIdx + 1) % len;
  }
}
void handleInboundFromRP(const char* line) {
  if (line[0] == '\0') return;
  // SYNC protocol
  if (!strcmp(line, "SYNC?")) {
    // Ignore; Nano only sends SYNC?, RP responds.
    return;
  }
  if (!strncmp(line, "SYNC RP ", 8)) {
    // RP2040 provided its hash; verify
    lastRPSyncHash = (uint32_t)strtoul(line + 8, nullptr, 10);
    uint32_t myHash = computeSyncHashNano();
    if (myHash == lastRPSyncHash) {
      syncOK = true;
      rplog(F("_ SYNCHASH OK\n"), rp);
      if (scanGatePending) {
        scanGatePending = false;
        doScanStartNow();
      }
    } else {
      syncOK = false;
      rplog(F("_ SYNCHASH BAD\n"), rp);
      resetFunc();
    }
    return;
  }
  if (!strcmp(line, "SYNC OK") || !strncmp(line, "SYNC BAD", 8)) {
    // RP shouldn't send these; ignore
    return;
  }
  if (!strcmp(line, "P")) {
    sendToken("P");
    return;
  }
  if (!strcmp(line, "PING")) {
    sendToken("PONG");
    return;
  }
  if (!strcmp(line, "READY?")) {
    delay(1000);
    rplog(F("READY\n"), rp);
    return;
  }
  if (!strcmp(line, "OK")) return;
  if (!strcmp(line, "HELP") || !strcmp(line, "?") || !strcmp(line, "H")) {
    sendHelp();
    return;
  }

  if (!strcmp(line, "SCAN?")) {
    rplog(F("_ Scan values query:\n"), rp);
    sendKV("_ SCAN", scanOn ? 1 : 0);
    sendKV("_ SRC", scanSrc ? 1 : 0);
    sendKV("_ DELAY", (long)scanDelayMs);
    sendKV("_ LEN", (long)currentListLen());
    return;
  }
  if (!strcmp(line, "SLCLR")) {
    customScanLen = 0;
    rplog(F("OK\n"), rp);
    return;
  }
  if (!strncmp(line, "SLADD ", 6)) {
    rplog(F("_ Scan list add:\n"), rp);
    long v = atol(line + 6);
    if (v <= 0) {
      rplog(F("_ ERR BAD_FREQ\n"), rp);
      return;
    }
    if (customScanLen >= MAX_CUSTOM_SCAN) {
      rplog(F("_ ERR FULL\n"), rp);
      return;
    }
    customScanList[customScanLen++] = (uint32_t)v;
    sendKV("_ LEN", (long)customScanLen);
    return;
  }
  if (!strncmp(line, "SDELAY ", 7)) {
    rplog(F("_ Scan delay:\n"), rp);
    long v = atol(line + 7);
    if (v < 10) v = 10;
    scanDelayMs = (uint32_t)v;
    sendKV("_ DELAY", (long)scanDelayMs);
    return;
  }
  if (!strncmp(line, "SCAN USE ", 9)) {
    rplog(F("_ Scan source (hard/custom):\n"), rp);
    const char* p = line + 9;
    if (!strcasecmp(p, "H") || !strcasecmp(p, "HARD")) scanUse(0);
    else if (!strcasecmp(p, "C") || !strcasecmp(p, "CUSTOM")) scanUse(1);
    else {
      rplog(F("_ ERR SRC\n"), rp);
      return;
    }
    sendKV("_ SRC", scanSrc ? 1 : 0);
    return;
  }
  if (!strncmp(line, "SCAN ", 5)) {
    rplog(F("_ Scan status query:\n"), rp);
    char buf[CMD_BUF_SZ];
    strncpy(buf, line, CMD_BUF_SZ - 1);
    buf[CMD_BUF_SZ - 1] = '\0';
    char* toks[6] = { 0 };
    int nt = 0;
    char* savep = nullptr;
    char* tk = strtok_r(buf, " ", &savep);
    while (tk && nt < 6) {
      toks[nt++] = tk;
      tk = strtok_r(nullptr, " ", &savep);
    }
    if (nt >= 2 && !strcasecmp(toks[1], "STOP")) {
      scanStop();
      return;
    }
    if (nt >= 2 && !strcasecmp(toks[1], "START")) {
      uint8_t src = scanSrc;
      uint32_t delayMs = scanDelayMs;
      for (int i = 2; i < nt; ++i) {
        if (!toks[i]) continue;
        if (!strcasecmp(toks[i], "H") || !strcasecmp(toks[i], "HARD")) src = 0;
        else if (!strcasecmp(toks[i], "C") || !strcasecmp(toks[i], "CUSTOM")) src = 1;
        else if (!strcasecmp(toks[i], "D")) {
          if (i + 1 < nt) {
            long v = atol(toks[i + 1]);
            if (v >= 10) delayMs = (uint32_t)v;
            i++;
          }
        } else if (toks[i][0] >= '0' && toks[i][0] <= '9') {
          long v = atol(toks[i]);
          if (v >= 10) delayMs = (uint32_t)v;
        }
      }
      scanUse(src);
      scanDelayMs = delayMs;
      scanStart();  // gated by SYNC
      return;
    }
    rplog(F("_ ERR SCAN\n"), rp);
    return;
  }

  // Parse KEY [VALUE]
  char key[16] = { 0 };
  long val = 0;
  int matched = sscanf(line, "%15s %ld", key, &val);
  if (matched >= 1) {
    if (!strcmp(key, "F") && matched == 2) {
      freq = (unsigned long)val;
    } else if (!strcmp(key, "IF") && matched == 2) {
      interfreq = val;
    } else if (!strcmp(key, "SM") && matched == 2) {
      if (val < 1) val = 1;
      if (val > 14) val = 14;
      x = (byte)val;
    } else if (!strcmp(key, "BAND") && matched == 2) {
      if (val < 1) val = 1;
      if (val > 21) val = 21;
      count = (byte)val;
    } else if (!strcmp(key, "STP") && matched == 2) {
      if (val < 1) val = 1;
      if (val > 6) val = 6;
      stp = (byte)val;
    } else if (!strcmp(key, "STS") && matched == 2) {
      sts = (val != 0);
    } else if (!strcmp(key, "N") && matched == 2) {
      if (val < 1) val = 1;
      if (val > 42) val = 42;
      n = (byte)val;
    } else if (!strcmp(key, "BAND_INIT") && matched == 2) {
      rp_band_init = val;
    } else if (!strcmp(key, "S_GAIN") && matched == 2) {
      rp_s_gain = val;
    } else if (!strcmp(key, "FOLD") && matched == 2) {
      if (val < 0) val = 0;
      freqold = (unsigned long)val;
    } else if (!strcmp(key, "FSTEP") && matched == 2) {
      if (val < 1) val = 1;
      fstep = (unsigned long)val;
    } else if (!strcmp(key, "SMVAL") && matched == 2) {
      long v = val;
      if (v < 1) v = 1;
      if (v > 14) v = 14;
      x = (byte)v;
    }
  }
}
// --------- Signal meter sampling + send when changed ----------
uint8_t lastSMBucket = 0;
unsigned long lastSMSendMs = 0;
const unsigned long SM_MIN_SEND_INTERVAL_MS = 10;
void sampleAndSendSignalMeter() {
  unsigned int raw = analogRead(adc);
  uint8_t bucket = map(raw, 0, S_GAIN, 1, 14);
  if (bucket > 14) bucket = 14;
  if (bucket < 1) bucket = 1;
  unsigned long now = millis();
  if (bucket != lastSMBucket && (now - lastSMSendMs) >= SM_MIN_SEND_INTERVAL_MS) {
    lastSMBucket = bucket;
    lastSMSendMs = now;
    //sendKV("SM", bucket);
    rplog(F("SM "), rp);
    rplog((String)bucket, rp, true);
  }
}
//------------------------------------------------------------------------------------------------------------
void setup() {
  Wire.setClock(100000);
  Wire.begin();
  pinMode(tunestep, INPUT_PULLUP);
  pinMode(band, INPUT_PULLUP);
  pinMode(rx_tx, INPUT_PULLUP);
  rp.begin(BAUD);
  rplog(F("P\n"), rp);
  si5351.init(SI5351_CRYSTAL_LOAD_8PF, 0, 0);
  si5351.set_correction(cal, SI5351_PLL_INPUT_XO);
  si5351.drive_strength(SI5351_CLK0, SI5351_DRIVE_8MA);
  si5351.output_enable(SI5351_CLK0, 1);
  si5351.output_enable(SI5351_CLK1, 0);
  si5351.output_enable(SI5351_CLK2, 0);
  lastRawTx = (digitalRead(rx_tx) == LOW);
  debouncedTx = lastRawTx;
  lastAnnouncedTx = debouncedTx;
  sts = debouncedTx ? 1 : 0;
  rp.println(debouncedTx ? "TX" : "RX");
  // Ask RP2040 to send its current state and SYNC hash
  rplog(F("Q\n"), rp);      // legacy state
  rplog(F("SYNC?\n"), rp);  // explicit sync
}
void loop() {
  if (readLine(rp, rpRxBuf, rpRxLen, CMD_BUF_SZ)) handleInboundFromRP(rpRxBuf);

  // Encoder/buttons proxy
  pollRxTx();
  if (digitalRead(tunestep) == LOW) {
    time_now = (millis() + 750);
    sendToken("T");
    delay(750);
  }
  if (digitalRead(band) == LOW) {
    time_now = (millis() + 750);
    sendToken("B");
    delay(750);
  }

  if (freqold != freq) {
    time_now = millis();
    tunegen();
    freqold = freq;
  }
  if (interfreqold != interfreq) {
    time_now = millis();
    tunegen();
    interfreqold = interfreq;
  }
  if (xo != x) {
    time_now = millis();
    xo = x;
  }
  sampleAndSendSignalMeter();
  scanTick();

  uint32_t now = millis();
  if ((now - lastBeatMs) >= beatIntervalMs) {
    lastBeatMs += beatIntervalMs;
    rplog(F("P\n"), rp);
  }
  if ((now - lastQueryMs) >= queryIntervalMs) {
    lastQueryMs += queryIntervalMs;
    rplog(F("Q\n"), rp);
    // If we had asked for sync but didn't get it yet, retry occasionally
    if (!syncOK && (now - lastSyncReqMs) >= SYNC_RETRY_MS) {
      requestSync();
    }
  }
}
void tunegen() {
  uint32_t ifHz = sts ? 0UL : (uint32_t)interfreq * 1000UL;
  uint64_t outCentiHz = ((uint64_t)freq + (uint64_t)ifHz) * 100ULL;
  si5351.set_freq(outCentiHz, SI5351_CLK0);
  rplog(F("K\n"), rp);
}
